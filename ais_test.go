// Package ais provides types and methods for conducting data science
// on signals generated by maritime entities radiating from an Automated
// Identification System (AIS) transponder as mandated by the International
// Maritime Organization (IMO) for all vessels over 300 gross tons and all
// passenger vessels.
package ais

import (
	"bytes"
	"encoding/csv"
	"fmt"
	"hash/fnv"
	"io"
	"reflect"
	"strings"
	"testing"
	"time"
)

func TestRecord_ParseInt(t *testing.T) {
	tests := []struct {
		r       Record
		index   int
		want    int64
		wantErr bool
	}{
		{Record{"67", "test_data"}, 0, 67, false},
		{Record{"alpha_data", "67"}, 0, 0, true}, // fail to parse
	}
	for _, test := range tests {
		got, err := test.r.ParseInt(test.index)
		if (err != nil) != test.wantErr {
			t.Errorf("Record.ParseInt() error = %v, wantErr %v", err, test.wantErr)
			return
		}
		if got != test.want {
			t.Errorf("Record.ParseInt() = %v, want %v", got, test.want)
		}
	}
}

func TestRecord_ParseFloat(t *testing.T) {
	tests := []struct {
		r       Record
		index   int
		want    float64
		wantErr bool
	}{
		{Record{"376494000", "2017-12-01T00:00:03", "30.28963", "-116.73522",
			"9.4", "158.2", "511.0"}, 2, 30.28963, false},
		{Record{"376494000", "2017-12-01T00:00:03", "30.28963", "-116.73522",
			"9.4", "158.2", "511.0"}, 3, -116.73522, false},
		{Record{"376494000", "2017-12-01T00:00:03", "30.28963", "-116.73522",
			"9.4", "158.2", "511.0"}, 1, 0, true},
	}
	for _, test := range tests {
		got, err := test.r.ParseFloat(test.index)
		if (err != nil) != test.wantErr {
			t.Errorf("Record.ParseFloat() error = %v, wantErr %v", err, test.wantErr)
			return
		}
		if got != test.want {
			t.Errorf("Record.ParseTime() = %v, want %v", got, test.want)
		}
	}
}

func TestRecord_ParseTime(t *testing.T) {
	tests := []struct {
		r       Record
		index   int
		want    time.Time
		wantErr bool
	}{
		// correct syntax - correct index
		{Record{"376494000", "2017-12-01T00:00:03", "30.28963", "-116.73522",
			"9.4", "158.2", "511.0"}, 1, getTime("2017-12-01T00:00:03"), false},
		// incorrect index
		{Record{"376494000", "2017-12-01T00:00:03", "30.28963", "-116.73522",
			"9.4", "158.2", "511.0"}, 0, time.Time{}, true},
		// incorrect time format
		{Record{"376494000", "12-01-2017T00:00:03", "30.28963", "-116.73522",
			"9.4", "158.2", "511.0"}, 1, time.Time{}, true},
	}
	for _, test := range tests {
		got, err := test.r.ParseTime(test.index)
		if (err != nil) != test.wantErr {
			t.Errorf("Record.ParseTime() error = %v, wantErr %v", err, test.wantErr)
			return
		}
		if got != test.want {
			t.Errorf("Record.ParseTime() = %v, want %v", got, test.want)
		}
	}
}

func getTime(s string) time.Time {
	t, _ := time.Parse(TimeLayout, s)
	return t
}

// func TestRecord_Parse(t *testing.T) {
// 	tests := []struct {
// 		name    string
// 		r       Record
// 		h       Headers
// 		want    Report
// 		wantErr bool
// 	}{
// 		{
// 			name: "Simple",
// 			r:    Record{"376494000", "2017-12-01T00:00:03", "30.28963", "-116.73522", "9.4", "158.2", "511.0"},
// 			h: Headers{
// 				fields:     []string{"MMSI", "BaseDateTime", "LAT", "LON", "SOG", "COG", "Heading"},
// 				dictionary: nil,
// 			},
// 			want:    Report{376494000, 30.28963, -116.73522, getTime("2017-12-01T00:00:03"), []interface{}{}},
// 			wantErr: false,
// 		},
// 		{
// 			name: "incomplete headers: no mmsi",
// 			r:    Record{"376494000", "2017-12-01T00:00:03", "30.28963", "-116.73522", "9.4", "158.2", "511.0"},
// 			h: Headers{
// 				fields:     []string{"BaseDateTime", "LAT", "LON", "SOG", "COG", "Heading"},
// 				dictionary: nil,
// 			},
// 			want:    Report{},
// 			wantErr: true,
// 		},
// 		{
// 			name: "unparsable mmsi",
// 			r:    Record{"376abc123", "2017-12-01T00:00:03", "30.28963", "-116.73522", "9.4", "158.2", "511.0"},
// 			h: Headers{
// 				fields:     []string{"MMSI", "BaseDateTime", "LAT", "LON", "SOG", "COG", "Heading"},
// 				dictionary: nil,
// 			},
// 			want:    Report{},
// 			wantErr: true,
// 		},
// 		{
// 			name: "unparsable time",
// 			r:    Record{"376494000", "12-01-2017T00:00:03", "30.28963", "-116.73522", "9.4", "158.2", "511.0"},
// 			h: Headers{
// 				fields:     []string{"MMSI", "BaseDateTime", "LAT", "LON", "SOG", "COG", "Heading"},
// 				dictionary: nil,
// 			},
// 			want:    Report{},
// 			wantErr: true,
// 		},
// 		{
// 			name: "unparsable Lat",
// 			r:    Record{"376494000", "2017-12-01T00:00:03", "3x.28963", "-116.73522", "9.4", "158.2", "511.0"},
// 			h: Headers{
// 				fields:     []string{"MMSI", "BaseDateTime", "LAT", "LON", "SOG", "COG", "Heading"},
// 				dictionary: nil,
// 			},
// 			want:    Report{},
// 			wantErr: true,
// 		},
// 		{
// 			name: "unparsable Lon",
// 			r:    Record{"376494000", "2017-12-01T00:00:03", "30.28963", "-1x6.73522", "9.4", "158.2", "511.0"},
// 			h: Headers{
// 				fields:     []string{"MMSI", "BaseDateTime", "LAT", "LON", "SOG", "COG", "Heading"},
// 				dictionary: nil,
// 			},
// 			want:    Report{},
// 			wantErr: true,
// 		},
// 	}
// 	for _, test := range tests {
// 		t.Run(test.name, func(t *testing.T) {
// 			got, err := test.r.Parse(test.h)
// 			// reflect.DeepEqual fails without the next statement because the address pointer for the
// 			// two arrays must be the same, they cannot just be empty slices of interface{}.
// 			got.data = test.want.data
// 			if (err != nil) != test.wantErr {
// 				t.Errorf("Record.Parse() error = %v, wantErr %v", err, test.wantErr)
// 				return
// 			}
// 			if !reflect.DeepEqual(got, test.want) {
// 				t.Errorf("Record.Parse() = %v, want %v", got, test.want)
// 			}
// 		})
// 	}
// }

func TestHeaders_Contains(t *testing.T) {
	type args struct {
		field string
	}
	tests := []struct {
		name   string
		h      Headers
		args   args
		wantI  int
		wantOk bool
	}{
		{
			name: "pass",
			h: Headers{
				fields:     []string{"MMSI", "BaseDateTime", "LAT", "LON", "SOG", "COG", "Heading"},
				dictionary: nil,
			},
			args:   args{"BaseDateTime"},
			wantI:  1,
			wantOk: true,
		},
		{
			name: "fail no mmsi",
			h: Headers{
				fields:     []string{"BaseDateTime", "LAT", "LON", "SOG", "COG", "Heading"},
				dictionary: nil,
			},
			args:   args{"MMSI"},
			wantI:  0,
			wantOk: false,
		},
		{
			name: "fail misspelled LON",
			h: Headers{
				fields:     []string{"MMSI", "BaseDateTime", "LAT", "Longitude", "SOG", "COG", "Heading"},
				dictionary: nil,
			},
			args:   args{"LON"},
			wantI:  0,
			wantOk: false,
		},
		{
			name:   "fail blank input headers",
			h:      Headers{fields: []string{}, dictionary: nil},
			args:   args{"BaseDateTime"},
			wantI:  0,
			wantOk: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			gotI, gotOk := tt.h.Contains(tt.args.field)
			if gotI != tt.wantI {
				t.Errorf("Headers.Contains() gotI = %v, want %v", gotI, tt.wantI)
			}
			if gotOk != tt.wantOk {
				t.Errorf("Headers.Contains() gotOk = %v, want %v", gotOk, tt.wantOk)
			}
		})
	}
}

func TestNewHeaders(t *testing.T) {
	type args struct {
		fields []string
		defs   []Definition
	}
	tests := []struct {
		name string
		args args
		want Headers
	}{
		{
			name: "pass minimum set",
			args: args{
				fields: []string{"MMSI", "LAT", "LON", "BaseDateTime"},
				defs:   nil,
			},
			want: Headers{
				fields:     []string{"MMSI", "LAT", "LON", "BaseDateTime"},
				dictionary: nil,
			},
		},
		{
			name: "pass with dictionary",
			args: args{
				fields: []string{"MMSI", "LAT", "LON", "BaseDateTime"},
				defs: []Definition{
					{Fieldname: "MMSI", Description: "Unique vessel identifier"},
					{Fieldname: "LAT", Description: "Latitude of the position report"},
					{Fieldname: "LON", Description: "Longitude of the position report"},
					{Fieldname: "BaseDateTime", Description: "Timestamp of the position report"},
				},
			},
			want: Headers{
				fields: []string{"MMSI", "LAT", "LON", "BaseDateTime"},
				dictionary: map[string]string{
					"MMSI":         "Some description",
					"LAT":          "Some description",
					"LON":          "Some description",
					"BaseDateTime": "Some description",
				},
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := NewHeaders(tt.args.fields, tt.args.defs); !got.Equals(tt.want) {
				t.Errorf("NewHeaders() = \n%v \nwant \n%v", got, tt.want)
			}
		})
	}
}

func TestBox_Match(t *testing.T) {
	data1 := strings.Split("477307900,2017-12-01T00:00:03,36.90512,-76.32652,0.0,131.0,352.0,FIRST,IMO9739666,VRPJ6,1004,moored,337,,,", ",")
	rec1 := Record(data1)

	nassau := strings.Split("477307900,2017-12-01T00:00:03,25.06,-77.345,0.0,131.0,352.0,FIRST,IMO9739666,VRPJ6,1004,moored,337,,,", ",")
	rec2 := Record(nassau)

	nassauBadLat := strings.Split("477307900,2017-12-01T00:00:03,25.06,-77.XXX,0.0,131.0,352.0,FIRST,IMO9739666,VRPJ6,1004,moored,337,,,", ",")
	rec3 := Record(nassauBadLat)

	nassauBadLon := strings.Split("477307900,2017-12-01T00:00:03,25.LL,-77.345,0.0,131.0,352.0,FIRST,IMO9739666,VRPJ6,1004,moored,337,,,", ",")
	rec4 := Record(nassauBadLon)

	type fields struct {
		MinLat   float64
		Maxlat   float64
		MinLon   float64
		MaxLon   float64
		LatIndex int
		LonIndex int
	}
	type args struct {
		rec *Record
	}
	tests := []struct {
		name    string
		fields  fields
		args    args
		want    bool
		wantErr bool
	}{
		{
			name:   "should fail",
			fields: fields{15, 27.5, -80, -60, 2, 3},
			args:   args{&rec1},
			want:   false,
		},
		{
			name:   "should pass",
			fields: fields{15, 27.5, -80, -60, 2, 3},
			args:   args{&rec2},
			want:   true,
		},
		{
			name:    "lat parse error",
			fields:  fields{15, 27.5, -80, -60, 2, 3},
			args:    args{&rec3},
			want:    false,
			wantErr: true,
		},
		{
			name:    "lon parse error",
			fields:  fields{15, 27.5, -80, -60, 2, 3},
			args:    args{&rec4},
			want:    false,
			wantErr: true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			b := &Box{
				MinLat:   tt.fields.MinLat,
				Maxlat:   tt.fields.Maxlat,
				MinLon:   tt.fields.MinLon,
				MaxLon:   tt.fields.MaxLon,
				LatIndex: tt.fields.LatIndex,
				LonIndex: tt.fields.LonIndex,
			}
			got, err := b.Match(tt.args.rec)
			if (err != nil) != tt.wantErr {
				t.Errorf("Box.Match() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if got != tt.want {
				t.Errorf("Box.Match() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestOpenRecordSet(t *testing.T) {

	tests := []struct {
		name     string
		filename string
		want     *RecordSet
		wantErr  bool
	}{
		{
			name:     "bad filename",
			filename: "doesNotExist.csv",
			want:     nil,
			wantErr:  true,
		},
		{
			name:     "empty file is unreadable",
			filename: "testdata/empty.csv",
			want:     nil,
			wantErr:  true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := OpenRecordSet(tt.filename)
			if (err != nil) != tt.wantErr {
				t.Errorf("OpenRecordSet() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("OpenRecordSet() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestRecordSet_readFirst(t *testing.T) {
	type fields struct {
		r     *csv.Reader
		w     *csv.Writer
		h     Headers
		data  io.ReadWriter
		first *Record
		stash *Record
	}
	tests := []struct {
		name    string
		fields  fields
		want    *Record
		wantErr bool
	}{
		{
			name: "readFirst test",
			fields: fields{
				r:     nil,
				w:     nil,
				h:     goodHeaders,
				data:  nil,
				first: &testRec0,
				stash: nil,
			},
			want:    &testRec0,
			wantErr: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			rs := &RecordSet{
				r:     tt.fields.r,
				w:     tt.fields.w,
				h:     tt.fields.h,
				data:  tt.fields.data,
				first: tt.fields.first,
				stash: tt.fields.stash,
			}
			got, err := rs.readFirst()
			if (err != nil) != tt.wantErr {
				t.Errorf("RecordSet.readFirst() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("RecordSet.readFirst() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestRecordSet_Stash(t *testing.T) {

	rs, _ := OpenRecordSet("testdata/ten.csv")
	type args struct {
		rec *Record
	}
	tests := []struct {
		name string
		rs   *RecordSet
		args args
		want *Record
	}{
		{
			name: "stash and then read",
			rs:   rs,
			args: args{
				rec: &testRec0,
			},
			want: &testRec0,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			rs.Stash(tt.args.rec)
			got, _ := rs.Read()
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("RecordSet.Stash() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestRecordSet_Read(t *testing.T) {
	type fields struct {
		r     *csv.Reader
		w     *csv.Writer
		h     Headers
		data  io.ReadWriter
		first *Record
		stash *Record
	}
	tests := []struct {
		name    string
		fields  fields
		want    *Record
		wantErr bool
	}{
		{
			name: "first is set",
			fields: fields{
				r:     nil,
				w:     nil,
				h:     goodHeaders,
				data:  nil,
				first: &testRec0,
				stash: nil,
			},
			want:    &testRec0,
			wantErr: false,
		},
		{
			name: "reader returns an error",
			fields: fields{
				r:     csv.NewReader(errorReader{}),
				w:     nil,
				h:     goodHeaders,
				data:  nil,
				first: nil,
				stash: nil,
			},
			want:    nil,
			wantErr: true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			rs := &RecordSet{
				r:     tt.fields.r,
				w:     tt.fields.w,
				h:     tt.fields.h,
				data:  tt.fields.data,
				first: tt.fields.first,
				stash: tt.fields.stash,
			}
			got, err := rs.Read()
			if (err != nil) != tt.wantErr {
				t.Errorf("RecordSet.Read() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("RecordSet.Read() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestRecordSet_SubsetLimit(t *testing.T) {
	type fields struct {
		r     *csv.Reader
		w     *csv.Writer
		h     Headers
		data  io.ReadWriter
		first *Record
		stash *Record
	}
	type args struct {
		m Matching
		n int
	}
	tests := []struct {
		name    string
		fields  fields
		args    args
		want    []uint64 // slice of Record.Hash()
		wantErr bool
	}{
		{
			name: "bad recordset read",
			fields: fields{
				r:     csv.NewReader(errorReader{}),
				w:     nil,
				h:     goodHeaders,
				data:  nil,
				first: nil,
				stash: nil,
			},
			args: args{
				m: &Box{
					MinLat: 0, Maxlat: 40, MinLon: -90, MaxLon: -70,
					LatIndex: 2, LonIndex: 3,
				},
				n: -1,
			},
			want:    []uint64{},
			wantErr: true,
		},
		{
			name: "bad matching function",
			fields: fields{
				r:     csv.NewReader(newTestReader()),
				w:     nil,
				h:     goodHeaders,
				data:  nil,
				first: nil,
				stash: nil,
			},
			args: args{
				m: &errorMatcher{},
				n: -1,
			},
			want:    []uint64{},
			wantErr: true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			rs := &RecordSet{
				r:     tt.fields.r,
				w:     tt.fields.w,
				h:     tt.fields.h,
				data:  tt.fields.data,
				first: tt.fields.first,
				stash: tt.fields.stash,
			}
			got, err := rs.SubsetLimit(tt.args.m, tt.args.n)
			if (err != nil) != tt.wantErr {
				t.Errorf("RecordSet.SubsetLimit() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			// Do not compare want if there is an error
			if err != nil {
				return
			}

			// Read the returned records into a slice of hashes
			hashes := []uint64{}
			for {
				rec, err := got.Read()
				if err == io.EOF {
					break
				}
				if err != nil {
					t.Errorf("test setup error: %v", err)
				}
				hash := rec.Hash()
				hashes = append(hashes, hash)
			}
			if !reflect.DeepEqual(hashes, tt.want) {
				t.Errorf("RecordSet.SubsetLimit() = %v, want %v", got, tt.want)
			}
		})
	}
}

func localHash(fields []string) uint64 {
	h64 := fnv.New64a()
	buf := new(bytes.Buffer)
	buf.WriteString(strings.Join(fields, ","))
	buf.WriteString("\n")
	_, err := h64.Write(buf.Bytes())
	if err != nil {
		msg := fmt.Sprintf("test setup error: %v", err)
		panic(msg)
	}

	return h64.Sum64()
}

func TestRecordSet_Track(t *testing.T) {
	// Designing tests for a RecordSet are non trivial.  After some amount of
	// consideration the best approach seemed to be testing for a slice of
	// hashes.  This will allow determining if the returned recordset contains
	// the right number of records and with some external calculation also ensure
	// that the right data was returned from a testdata .csv file.

	type args struct {
		mmsi  int64
		start time.Time
		dur   time.Duration
	}
	tests := []struct {
		name             string
		filename         string
		args             args
		recs             [][]string
		want             []uint64 //hash values of each Record in the set
		wantErr          bool
		wantErrSubstring string
	}{
		{
			name:     "one record from ten.csv",
			filename: "testdata/ten.csv",
			args: args{
				mmsi:  477307901, // corresponds to the vessel FIRST
				start: Beginning,
				dur:   All,
			},
			recs:             [][]string{firstRec},
			want:             []uint64{localHash(firstRec)},
			wantErr:          false,
			wantErrSubstring: "",
		},
		{
			name:     "three records from track.csv",
			filename: "testdata/track.csv",
			args: args{
				mmsi:  477307901, // corresponds to the vessel FIRST
				start: Beginning,
				dur:   All,
			},
			recs:             [][]string{track1, track2, track3},
			want:             []uint64{localHash(track1), localHash(track2), localHash(track3)},
			wantErr:          false,
			wantErrSubstring: "",
		},
		{
			name:     "empty recordset due to mmsi",
			filename: "testdata/ten.csv",
			args: args{
				mmsi:  477307905, // mmsi not in ten.csv
				start: Beginning,
				dur:   All,
			},
			want:             []uint64{},
			wantErr:          true,
			wantErrSubstring: "ErrEmptySet",
		},
		{
			name:     "error due to bad time parse",
			filename: "testdata/badTimeData.csv",
			args: args{
				mmsi:  477307901, // corresponds to the vessel FIRST
				start: Beginning,
				dur:   All,
			},
			want:             []uint64{},
			wantErr:          true,
			wantErrSubstring: "cannot parse",
		},
		{
			name:     "error due to bad MMSI parse",
			filename: "testdata/badMMSIData.csv",
			args: args{
				mmsi:  477307901, // corresponds to the vessel FIRST
				start: Beginning,
				dur:   All,
			},
			want:             []uint64{},
			wantErr:          true,
			wantErrSubstring: "invalid syntax",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			rs, err := OpenRecordSet(tt.filename)
			if err != nil {
				t.Errorf("test setup error: %v", err)
				return
			}

			got, err := rs.Track(tt.args.mmsi, tt.args.start, tt.args.dur)

			// If err returns non-nil from the first call then skip the second call and
			// pass the returned error into the processing logic.  For nil errors then it
			// should return the exact same result on successive calls.
			// See issue #35 and #36 for details.
			if err == nil {
				got, err = rs.Track(tt.args.mmsi, tt.args.start, tt.args.dur)
			}

			// Check for the presence of an error
			if (err != nil) && !tt.wantErr {
				t.Errorf("RecordSet.Track() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			// Check that the error has the correct substring
			// NOTE: the substring "" always validates
			if (err != nil) && !strings.Contains(err.Error(), tt.wantErrSubstring) {
				t.Errorf("RecordSet.Track() error = %v, wantErrSubstring %v", err, tt.wantErrSubstring)
				return
			}
			// Only try and read from the RecordSet if err==nil
			if err != nil {
				return
			}

			// Convert the returned recordset into a slice of hash values for each record
			var hashes = []uint64{}
			for {
				rec, err := got.Read()
				if err == io.EOF {
					break
				}
				if err != nil {
					t.Errorf("test setup error: %v", err)
					return
				}

				hash := rec.Hash()
				hashes = append(hashes, hash)
			}
			if !reflect.DeepEqual(hashes, tt.want) {
				t.Errorf("RecordSet.Track() = %v, want %v", hashes, tt.want)
			}
		})
	}
}

func TestRecordSet_Track_Continued(t *testing.T) {
	// Designing tests for a RecordSet are non trivial.  After some amount of
	// consideration the best approach seemed to be testing for a slice of
	// hashes.  This will allow determining if the returned recordset contains
	// the right number of records and with some external calculation also ensure
	// that the right data was returned from a testdata .csv file.

	type fields struct {
		r     *csv.Reader
		w     *csv.Writer
		h     Headers
		data  io.ReadWriter
		first *Record
		stash *Record
	}
	type args struct {
		mmsi  int64
		start time.Time
		dur   time.Duration
	}
	tests := []struct {
		name    string
		fields  fields
		args    args
		want    []uint64 // slice of Record.Hash()
		wantErr bool
	}{
		{
			name: "bad RecordSet has no MMSI in headers",
			fields: fields{
				r:     nil,
				w:     nil,
				h:     badHeaders2,
				data:  nil,
				first: nil,
				stash: nil,
			},
			args: args{
				mmsi: 477307901, start: Beginning, dur: All,
			},
			want:    []uint64{},
			wantErr: true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			rs := &RecordSet{
				r:     tt.fields.r,
				w:     tt.fields.w,
				h:     tt.fields.h,
				data:  tt.fields.data,
				first: tt.fields.first,
				stash: tt.fields.stash,
			}
			got, err := rs.Track(tt.args.mmsi, tt.args.start, tt.args.dur)
			if (err != nil) != tt.wantErr {
				t.Errorf("RecordSet.Track() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			// Do not compare want if there is an error
			if err != nil {
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("RecordSet.Track() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_newSubsetByTrack(t *testing.T) {
	type args struct {
		rs    *RecordSet
		mmsi  int64
		start time.Time
		dur   time.Duration
	}
	tests := []struct {
		name             string
		args             args
		want             *subsetByTrack
		wantErrSubstring string
	}{
		{
			name: "recordset with no MMSI header",
			args: args{
				rs: &RecordSet{
					r:     nil,
					w:     nil,
					h:     badHeaders2,
					data:  nil,
					first: nil,
					stash: nil,
				},
				mmsi:  477307901, // corresponds to the vessel FIRST
				start: Beginning,
				dur:   All,
			},
			want:             nil,
			wantErrSubstring: "missing header MMSI",
		},
		{
			name: "recordset with no BaseDateTime header",
			args: args{
				rs: &RecordSet{
					r:     nil,
					w:     nil,
					h:     badHeaders,
					data:  nil,
					first: nil,
					stash: nil,
				},
				mmsi:  477307901, // corresponds to the vessel FIRST
				start: Beginning,
				dur:   All,
			},
			want:             nil,
			wantErrSubstring: "missing header BaseDateTime",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := newSubsetByTrack(tt.args.rs, tt.args.mmsi, tt.args.start, tt.args.dur)
			if (err != nil) && !strings.Contains(err.Error(), tt.wantErrSubstring) {
				t.Errorf("newSubsetByTrack() error = %v, wantErrSubstring %v", err, tt.wantErrSubstring)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("newSubsetByTrack() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestRecordSet_UniqueVessels(t *testing.T) {
	type fields struct {
		r     *csv.Reader
		w     *csv.Writer
		h     Headers
		data  io.ReadWriter
		first *Record
		stash *Record
	}
	tests := []struct {
		name             string
		fields           fields
		skipHeaders      bool
		want             VesselSet
		wantErr          bool
		wantErrSubstring string
	}{
		{
			name: "basic usage",
			fields: fields{
				r: csv.NewReader(strings.NewReader(testString)),
			},
			skipHeaders:      false,
			want:             VesselSet{{"477307901", "FIRST"}: true, {"338029922", "SECOND"}: true, {"369080003", "THIRD"}: true},
			wantErr:          false,
			wantErrSubstring: "",
		},
		{
			name: "no mmsi header",
			fields: fields{
				r: csv.NewReader(strings.NewReader(testStringBadHeader1)),
			},
			skipHeaders:      false,
			want:             nil,
			wantErr:          true,
			wantErrSubstring: "does not contain MMSI",
		},
		{
			name: "no vessel name header",
			fields: fields{
				r: csv.NewReader(strings.NewReader(testStringBadHeader2)),
			},
			skipHeaders:      false,
			want:             VesselSet{{"477307901", "no VesselName header"}: true, {"338029922", "no VesselName header"}: true, {"369080003", "no VesselName header"}: true},
			wantErr:          false,
			wantErrSubstring: "",
		},
		{
			name: "bad reader",
			fields: fields{
				r: csv.NewReader(&errorReader{}),
				h: goodHeaders,
			},
			skipHeaders:      true,
			want:             nil,
			wantErr:          true,
			wantErrSubstring: "errorReader used for testing",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			rs := &RecordSet{
				r:     tt.fields.r,
				w:     tt.fields.w,
				data:  tt.fields.data,
				first: tt.fields.first,
				stash: tt.fields.stash,
			}
			rs.r.LazyQuotes = true
			rs.r.Comment = '#'
			if tt.skipHeaders {
				rs.h = tt.fields.h
			} else {
				rec, _ := rs.Read()
				rs.SetHeaders(Headers{[]string(*rec), nil})
			}
			got, err := rs.UniqueVessels()
			if (err != nil) != tt.wantErr {
				t.Errorf("RecordSet.UniqueVessels() error = %v, wantErr = %v", err, tt.wantErr)
				return
			}
			if (err != nil) && !strings.Contains(err.Error(), tt.wantErrSubstring) {
				t.Errorf("RecordSet.UniqueVessels() error = %v, wantErrSubstring = %v", err, tt.wantErrSubstring)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("RecordSet.UniqueVessels() = %v, want = %v", got, tt.want)
			}
		})
	}
}

func TestRecordSet_UniqueVessels_DoubleUse(t *testing.T) {
	type fields struct {
		r     *csv.Reader
		w     *csv.Writer
		h     Headers
		data  io.ReadWriter
		first *Record
		stash *Record
	}
	tests := []struct {
		name        string
		fields      fields
		skipHeaders bool
		want        VesselSet
		wantErr     bool
	}{
		{
			name: "double use",
			fields: fields{
				r: csv.NewReader(strings.NewReader(testString)),
			},
			skipHeaders: false,
			want:        VesselSet{{"477307901", "FIRST"}: true, {"338029922", "SECOND"}: true, {"369080003", "THIRD"}: true},
			wantErr:     false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			rs := &RecordSet{
				r:     tt.fields.r,
				w:     tt.fields.w,
				data:  tt.fields.data,
				first: tt.fields.first,
				stash: tt.fields.stash,
			}
			rs.r.LazyQuotes = true
			rs.r.Comment = '#'
			if tt.skipHeaders {
				rs.h = tt.fields.h
			} else {
				rec, _ := rs.Read()
				rs.SetHeaders(Headers{[]string(*rec), nil})
			}
			got, _ := rs.UniqueVessels()
			// got, _ = rs.UniqueVessels()
			// got, _ = rs.UniqueVessels()
			got, err := rs.UniqueVessels()
			if (err != nil) != tt.wantErr {
				t.Errorf("RecordSet.UniqueVessels() error = %v, wantErr = %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("RecordSet.UniqueVessels() = %v, want = %v", got, tt.want)
			}
		})
	}
}
