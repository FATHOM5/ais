// Package ais provides types and methods for conducting data science
// on signals generated by maritime entities radiating from an Automated
// Identification System (AIS) transponder as mandated by the International
// Maritime Organization (IMO) for all vessels over 300 gross tons and all
// passenger vessels.
package ais

import (
	"reflect"
	"testing"
	"time"
)

func TestRecord_ParseInt(t *testing.T) {
	tests := []struct {
		r       Record
		index   int
		want    int64
		wantErr bool
	}{
		{Record{"67", "test_data"}, 0, 67, false},
		{Record{"alpha_data", "67"}, 0, 0, true}, // fail to parse
	}
	for _, test := range tests {
		got, err := test.r.ParseInt(test.index)
		if (err != nil) != test.wantErr {
			t.Errorf("Record.ParseInt() error = %v, wantErr %v", err, test.wantErr)
			return
		}
		if got != test.want {
			t.Errorf("Record.ParseInt() = %v, want %v", got, test.want)
		}
	}
}

func TestRecord_ParseFloat(t *testing.T) {
	tests := []struct {
		r       Record
		index   int
		want    float64
		wantErr bool
	}{
		{Record{"376494000", "2017-12-01T00:00:03", "30.28963", "-116.73522",
			"9.4", "158.2", "511.0"}, 2, 30.28963, false},
		{Record{"376494000", "2017-12-01T00:00:03", "30.28963", "-116.73522",
			"9.4", "158.2", "511.0"}, 3, -116.73522, false},
		{Record{"376494000", "2017-12-01T00:00:03", "30.28963", "-116.73522",
			"9.4", "158.2", "511.0"}, 1, 0, true},
	}
	for _, test := range tests {
		got, err := test.r.ParseFloat(test.index)
		if (err != nil) != test.wantErr {
			t.Errorf("Record.ParseFloat() error = %v, wantErr %v", err, test.wantErr)
			return
		}
		if got != test.want {
			t.Errorf("Record.ParseTime() = %v, want %v", got, test.want)
		}
	}
}

func TestRecord_ParseTime(t *testing.T) {
	tests := []struct {
		r       Record
		index   int
		want    time.Time
		wantErr bool
	}{
		// correct syntax - correct index
		{Record{"376494000", "2017-12-01T00:00:03", "30.28963", "-116.73522",
			"9.4", "158.2", "511.0"}, 1, getTime("2017-12-01T00:00:03"), false},
		// incorrect index
		{Record{"376494000", "2017-12-01T00:00:03", "30.28963", "-116.73522",
			"9.4", "158.2", "511.0"}, 0, time.Time{}, true},
		// incorrect time format
		{Record{"376494000", "12-01-2017T00:00:03", "30.28963", "-116.73522",
			"9.4", "158.2", "511.0"}, 1, time.Time{}, true},
	}
	for _, test := range tests {
		got, err := test.r.ParseTime(test.index)
		if (err != nil) != test.wantErr {
			t.Errorf("Record.ParseTime() error = %v, wantErr %v", err, test.wantErr)
			return
		}
		if got != test.want {
			t.Errorf("Record.ParseTime() = %v, want %v", got, test.want)
		}
	}
}

func getTime(s string) time.Time {
	t, _ := time.Parse(TimeLayout, s)
	return t
}

func TestRecord_Parse(t *testing.T) {
	tests := []struct {
		name    string
		r       Record
		h       Headers
		want    Report
		wantErr bool
	}{
		{
			name: "Simple",
			r:    Record{"376494000", "2017-12-01T00:00:03", "30.28963", "-116.73522", "9.4", "158.2", "511.0"},
			h: Headers{
				fields:     []string{"MMSI", "BaseDateTime", "LAT", "LON", "SOG", "COG", "Heading"},
				dictionary: nil,
			},
			want:    Report{376494000, 30.28963, -116.73522, getTime("2017-12-01T00:00:03"), []interface{}{}},
			wantErr: false,
		},
		{
			name: "incomplete headers: no mmsi",
			r:    Record{"376494000", "2017-12-01T00:00:03", "30.28963", "-116.73522", "9.4", "158.2", "511.0"},
			h: Headers{
				fields:     []string{"BaseDateTime", "LAT", "LON", "SOG", "COG", "Heading"},
				dictionary: nil,
			},
			want:    Report{},
			wantErr: true,
		},
		{
			name: "unparsable mmsi",
			r:    Record{"376abc123", "2017-12-01T00:00:03", "30.28963", "-116.73522", "9.4", "158.2", "511.0"},
			h: Headers{
				fields:     []string{"MMSI", "BaseDateTime", "LAT", "LON", "SOG", "COG", "Heading"},
				dictionary: nil,
			},
			want:    Report{},
			wantErr: true,
		},
		{
			name: "unparsable time",
			r:    Record{"376494000", "12-01-2017T00:00:03", "30.28963", "-116.73522", "9.4", "158.2", "511.0"},
			h: Headers{
				fields:     []string{"MMSI", "BaseDateTime", "LAT", "LON", "SOG", "COG", "Heading"},
				dictionary: nil,
			},
			want:    Report{},
			wantErr: true,
		},
		{
			name: "unparsable Lat",
			r:    Record{"376494000", "2017-12-01T00:00:03", "3x.28963", "-116.73522", "9.4", "158.2", "511.0"},
			h: Headers{
				fields:     []string{"MMSI", "BaseDateTime", "LAT", "LON", "SOG", "COG", "Heading"},
				dictionary: nil,
			},
			want:    Report{},
			wantErr: true,
		},
		{
			name: "unparsable Lon",
			r:    Record{"376494000", "2017-12-01T00:00:03", "30.28963", "-1x6.73522", "9.4", "158.2", "511.0"},
			h: Headers{
				fields:     []string{"MMSI", "BaseDateTime", "LAT", "LON", "SOG", "COG", "Heading"},
				dictionary: nil,
			},
			want:    Report{},
			wantErr: true,
		},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			got, err := test.r.Parse(test.h)
			// reflect.DeepEqual fails without the next statement because the address pointer for the
			// two arrays must be the same, they cannot just be empty slices of interface{}.
			got.data = test.want.data
			if (err != nil) != test.wantErr {
				t.Errorf("Record.Parse() error = %v, wantErr %v", err, test.wantErr)
				return
			}
			if !reflect.DeepEqual(got, test.want) {
				t.Errorf("Record.Parse() = %v, want %v", got, test.want)
			}
		})
	}
}

func TestHeaders_Contains(t *testing.T) {
	type args struct {
		field string
	}
	tests := []struct {
		name   string
		h      Headers
		args   args
		wantI  int
		wantOk bool
	}{
		{
			name: "pass",
			h: Headers{
				fields:     []string{"MMSI", "BaseDateTime", "LAT", "LON", "SOG", "COG", "Heading"},
				dictionary: nil,
			},
			args:   args{"BaseDateTime"},
			wantI:  1,
			wantOk: true,
		},
		{
			name: "fail no mmsi",
			h: Headers{
				fields:     []string{"BaseDateTime", "LAT", "LON", "SOG", "COG", "Heading"},
				dictionary: nil,
			},
			args:   args{"MMSI"},
			wantI:  0,
			wantOk: false,
		},
		{
			name: "fail misspelled LON",
			h: Headers{
				fields:     []string{"MMSI", "BaseDateTime", "LAT", "Longitude", "SOG", "COG", "Heading"},
				dictionary: nil,
			},
			args:   args{"LON"},
			wantI:  0,
			wantOk: false,
		},
		{
			name:   "fail blank input headers",
			h:      Headers{fields: []string{}, dictionary: nil},
			args:   args{"BaseDateTime"},
			wantI:  0,
			wantOk: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			gotI, gotOk := tt.h.Contains(tt.args.field)
			if gotI != tt.wantI {
				t.Errorf("Headers.Contains() gotI = %v, want %v", gotI, tt.wantI)
			}
			if gotOk != tt.wantOk {
				t.Errorf("Headers.Contains() gotOk = %v, want %v", gotOk, tt.wantOk)
			}
		})
	}
}

func TestHeaders_Valid(t *testing.T) {
	type fields struct {
		fields     []string
		dictionary map[string]string
	}
	tests := []struct {
		name   string
		fields fields
		want   bool
	}{
		{
			name: "pass",
			fields: fields{
				fields:     []string{"MMSI", "LAT", "LON", "BaseDateTime"},
				dictionary: nil,
			},
			want: true,
		},
		{
			name: "missing MMSI",
			fields: fields{
				fields:     []string{"LAT", "LON", "BaseDateTime"},
				dictionary: nil,
			},
			want: false,
		},
		{
			name: "lowercase mmsi",
			fields: fields{
				fields:     []string{"mmsi", "LAT", "LON", "BaseDateTime"},
				dictionary: nil,
			},
			want: false,
		},
		{
			name: "missing LAT",
			fields: fields{
				fields:     []string{"MMSI", "LON", "BaseDateTime"},
				dictionary: nil,
			},
			want: false,
		},

		{
			name: "spelled Longitude",
			fields: fields{
				fields:     []string{"MMSI", "LAT", "Longitude", "BaseDateTime"},
				dictionary: nil,
			},
			want: false,
		},
		{
			name: "timestamp instead of BaseDateTime",
			fields: fields{
				fields:     []string{"MMSI", "LAT", "LON", "timestamp"},
				dictionary: nil,
			},
			want: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			h := Headers{
				fields:     tt.fields.fields,
				dictionary: tt.fields.dictionary,
			}
			if got := h.Valid(); got != tt.want {
				t.Errorf("Headers.Valid() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestNewHeaders(t *testing.T) {
	type args struct {
		fields []string
		defs   []Definition
	}
	tests := []struct {
		name string
		args args
		want Headers
	}{
		{
			name: "pass minimum set",
			args: args{
				fields: []string{"MMSI", "LAT", "LON", "BaseDateTime"},
				defs:   nil,
			},
			want: Headers{
				fields:     []string{"MMSI", "LAT", "LON", "BaseDateTime"},
				dictionary: nil,
			},
		},
		{
			name: "pass with dictionary",
			args: args{
				fields: []string{"MMSI", "LAT", "LON", "BaseDateTime"},
				defs: []Definition{
					Definition{Fieldname: "MMSI", Description: "Unique vessel identifier"},
					Definition{Fieldname: "LAT", Description: "Latitude of the position report"},
					Definition{Fieldname: "LON", Description: "Longitude of the position report"},
					Definition{Fieldname: "BaseDateTime", Description: "Timestamp of the position report"},
				},
			},
			want: Headers{
				fields: []string{"MMSI", "LAT", "LON", "BaseDateTime"},
				dictionary: map[string]string{
					"MMSI":         "Some description",
					"LAT":          "Some description",
					"LON":          "Some description",
					"BaseDateTime": "Some description",
				},
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := NewHeaders(tt.args.fields, tt.args.defs); !got.Equals(tt.want) {
				t.Errorf("NewHeaders() = \n%v \nwant \n%v", got, tt.want)
			}
		})
	}
}
